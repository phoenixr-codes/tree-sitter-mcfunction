// @ts-check

const marked = require("marked");
const fm = require("front-matter");
const { JSDOM } = require("jsdom");
const { snake } = require("case");
const path = require("node:path");
const fs = require("node:fs");
const { tmpdir } = require("node:os");
const { spawn } = require("node:child_process");
const { exit, env } = require("node:process");

const repoUrl = "https://github.com/MicrosoftDocs/minecraft-creator.git";
const repoPath = env.MINECRAFT_CREATOR ?? path.join(tmpdir(), "minecraft-creator");
const root = __dirname;

const outputPath = path.join(root, "data/commands.cjs");

/**
 * @typedef {{literal: string} | {type: string, required: boolean}} CommandToken
 */

/**
 * Runs a command.
 *
 * @param {string} command 
 * @param {string[]} args 
 */
function run(command, args) {
  return new Promise((resolve, reject) => {
    const cmd = spawn(command, args, { stdio: "inherit" });

    cmd.on("error", (err) => {
      reject(err);
    });

    cmd.on("close", (code) => {
      if (code === 0) {
        resolve(null);
      } else {
        reject(code);
      }
    });
  });
}

/**
 * @param {string} markdown 
 */
function preprocess(markdown) {
  const { body } = fm(markdown);
  return body;
}

let lastHeadingDepth = 0;

/**
 * Renderer that wraps every heading's content in its own section element.
 */
const renderer = {
  heading({ tokens, depth }) {
    let res = "";
    const text = this.parser.parseInline(tokens);
    for (let i = depth; i <= lastHeadingDepth; i++) {
      res += `</section>\n`;
    }
    res += `<section id="${snake(text)}">\n`;
    res += `<h${depth}>${text}</h${depth}>\n`;
    lastHeadingDepth = depth;
    return res;
  }
}

/**
 * @param {string} input
 * @returns {CommandToken[]}
 */
function parseCommandSyntax(input) {
  const requiredParamPattern = /<([^>]+)>/g;
  const optionalParamPattern = /\[([^\]]+)\]/g;
  const constantParamPattern = /(\w+)/g;

  /** @type [number, number, CommandToken][] */
  const matches = [];

  for (const match of input.matchAll(optionalParamPattern)) {
    const overlaps = matches.some(([start, end]) => match.index >= start && match.index <= end);
    if (overlaps) continue;
    const type = (match[1].split(": ")[1] ?? "TODO").split(" ").join("");
    const start = match.index;
    const end = match.index + match[0].length;
    matches.push([start, end, { type, required: false }]);
  }

  for (const match of input.matchAll(requiredParamPattern)) {
    const overlaps = matches.some(([start, end]) => match.index >= start && match.index <= end);
    if (overlaps) continue;
    const type = (match[1].split(": ")[1] ?? "TODO").split(" ").join("");
    const start = match.index;
    const end = match.index + match[0].length;
    matches.push([start, end, { type, required: true }]);
  }

  for (const match of input.matchAll(constantParamPattern)) {
    const overlaps = matches.some(([start, end]) => match.index >= start && match.index <= end);
    if (overlaps) continue;
    const constant = match[1];
    const start = match.index;
    const end = match.index + match[0].length;
    matches.push([start, end, { literal: constant }]);
  }

  matches.sort((a, b) => a[0] - b[0]);
  return matches.map(([_start, _end, token]) => token);
}

(async () => {
  if (fs.existsSync(repoPath)) {
    try {
      await run("git", ["-C", repoPath, "pull"]);
    } catch (err) {
      console.error(err);
      exit(1);
    }
  } else {
    try {
      await run("git", ["clone", "--depth", "1", repoUrl, repoPath]);
    } catch (err) {
      console.error(err);
      exit(1);
    }
  }

  let output = "// This file was generated by fetch-commands.cjs; do not manually edit\nmodule.exports = {\n";
  const commandsPath = path.join(repoPath, "creator/Commands/commands");
  const enumsPath = path.join(repoPath, "creator/Commands/enums");
  for (const fileName of fs.readdirSync(enumsPath)) {
    const filePath = path.join(enumsPath, fileName);
    const content = fs.readFileSync(filePath, "utf8");
    const enumName = snake(path.basename(fileName, ".md"));
    output += `  _${enumName}: _ => choice(\n`;
    lastHeadingDepth = 0;
    marked.use({hooks: { preprocess }, renderer });
    const html = await marked.parse(content);
    const dom = new JSDOM(html);
    const { document } = dom.window;

    const variants = document.querySelectorAll("#values ul li code");
    variants.forEach(({textContent: variant}) => {
      if (variant === null) {
        throw new Error("unreachable: empty enum variant");
      }
      output += `    "${variant}",\n`;
    });
    output += "),";
  }
  for (const fileName of fs.readdirSync(commandsPath)) {
    const filePath = path.join(commandsPath, fileName);
    const content = fs.readFileSync(filePath, "utf8");
    const commandName = path.basename(fileName, ".md");
    //output += `  ${commandName}_cmd: _ => "${commandName}",\n`; // FIXME
    output += `  ${commandName}: $ => choice(\n`;
    lastHeadingDepth = 0;
    marked.use({ hooks: { preprocess }, renderer });
    const html = await marked.parse(content);
    //console.log(html);
    const dom = new JSDOM(html);
    const { document } = dom.window;

    const commands = document.querySelectorAll("#usage code");
    commands.forEach(({textContent: command}) => {
      if (command?.startsWith("/")) {
        const tokens = parseCommandSyntax(command);
        let reachedOptionals = false;
        let firstLiteral = false; // TODO: change this to true here
        output += "    seq(";
        for (const token of tokens) {
          if ("literal" in token) {
            if (firstLiteral) {
              output += `$.${token.literal}_cmd,`;
              firstLiteral = false;
            } else {
              output += `"${token.literal}",`;
            }
          } else if ("type" in token) {
            if (!reachedOptionals && !token.required) {
              reachedOptionals = true;
              output += "optional(seq(";
            }
            output += `$._${snake(token.type)},`;
          }
        }
        if (reachedOptionals) {
          output += "))";
        }
        output += "),\n";
      }
    });
    output += "  ),\n";

    const enums = document.querySelectorAll("#enums h3");
    enums.forEach((el) => {
      const { textContent: enumName } = el;
      if (enumName === null) {
        throw new Error("unreachable: empty enum name");
      }
      output += `  _${snake(enumName)}: _ => choice(`;
      const variants = el.parentElement?.querySelectorAll("ul li code");
      variants?.forEach(({textContent: variant}) => {
        if (variant === null) {
          throw new Error("unreachable: empty enum variant");
        }
        output += `"${variant}",`;
      });
      output += "),\n";
    });
  }
  output += "};";

  fs.writeFileSync(outputPath, output);
})();
